#include "Lighting.hpp"#include <set>#include "Graphics.hpp"#include "Components/LightComponent.hpp"#include "SceneObject.hpp"namespace Spinner{    Lighting::Lighting(uint32_t lightCount, uint32_t shadowCount) : MaxLightCount(lightCount), MaxShadowCount(shadowCount)    {        assert(lightCount > 0);        LightInfoBuffer = Buffer::CreateBuffer(sizeof(LightInfo), vk::BufferUsageFlagBits::eUniformBuffer | vk::BufferUsageFlagBits::eTransferSrc | vk::BufferUsageFlagBits::eTransferDst, vma::MemoryUsage::eCpuToGpu, 0, true);        LightBuffer = Buffer::CreateBuffer(sizeof(Light) * MaxLightCount, vk::BufferUsageFlagBits::eStorageBuffer | vk::BufferUsageFlagBits::eTransferSrc | vk::BufferUsageFlagBits::eTransferDst, vma::MemoryUsage::eCpuToGpu, 0, true);        ShadowSampler = Sampler::CreateSampler(vk::Filter::eLinear, vk::SamplerMipmapMode::eLinear, vk::SamplerAddressMode::eRepeat, 8, vk::CompareOp::eLess);    }    void Lighting::UpdateLights(glm::vec3 viewerPosition, const std::vector<Components::LightComponent *> &lightComponents)    {        // Ignore None lights        // Sort directional lights first        // Prioritize shadow casters        // Sort others by distance from viewerPosition        auto sortFunc = [viewerPosition](const Components::LightComponent *a, const Components::LightComponent *b) -> bool        {            auto aLightType = a->GetLightType();            auto bLightType = b->GetLightType();            if (aLightType == LightType::Directional || bLightType == LightType::Directional)            {                if (aLightType != bLightType)                {                    return aLightType == LightType::Directional; // only sort A down if A is a directional                }            }            bool aShadowCaster = a->GetIsShadowCaster();            bool bShadowCaster = b->GetIsShadowCaster();            if (aShadowCaster != bShadowCaster)            {                return aShadowCaster < bShadowCaster; // only sort A down if A is a shadow caster (and b is not)            }            glm::vec3 aPos = a->GetSceneObject()->GetWorldPosition();            glm::vec3 bPos = b->GetSceneObject()->GetWorldPosition();            float distA = glm::distance2(viewerPosition, aPos);            float distB = glm::distance2(viewerPosition, bPos);            if (distA != distB)            {                return distA < distB;            }            // If two lights are both not directional, both are in the same position then compare the pointers            return reinterpret_cast<size_t>(a) < reinterpret_cast<size_t>(b);        };        std::set<Components::LightComponent *, decltype(sortFunc)> sortedLights(sortFunc);        for (auto &lightComponent : lightComponents)        {            if (lightComponent == nullptr || lightComponent->GetSceneObjectWeak().expired())            {                continue;            }            if (lightComponent->GetLightType() == LightType::None)            {                continue;            }            sortedLights.emplace(lightComponent);        }        ShadowImages.clear();        SortedLightComponents.clear();        std::vector<Light> finalLights;        for (auto &lightComponent : sortedLights)        {            if (finalLights.size() >= MaxLightCount)            {                break;            }            SortedLightComponents.push_back(lightComponent);            finalLights.push_back(lightComponent->GetLight());            ShadowImages.push_back(lightComponent->GetShadowMapImage());        }        uint32_t lightCount = std::min(static_cast<uint32_t>(finalLights.size()), MaxLightCount);        uint32_t shadowCount = std::min(static_cast<uint32_t>(ShadowImages.size()), MaxShadowCount);        LightBuffer->Write(finalLights.data(), sizeof(Light) * lightCount, 0, nullptr);        LightInfo lightInfo{};        lightInfo.LightCount = lightCount;        lightInfo.ShadowCount = shadowCount;        LightInfoBuffer->Write(lightInfo, nullptr);    }    void Lighting::UpdateDescriptors(vk::DescriptorSet set, bool shadowsOnly)    {        constexpr uint32_t LightInfoBinding = 0;        constexpr uint32_t LightBufferBinding = 1;        constexpr uint32_t ShadowBinding = 2;        if (!shadowsOnly)        {            // Light info and light storage buffer            vk::DescriptorBufferInfo lightInfoBufferInfo;            lightInfoBufferInfo.buffer = LightInfoBuffer->VkBuffer;            lightInfoBufferInfo.offset = 0;            lightInfoBufferInfo.range = vk::WholeSize;            vk::WriteDescriptorSet lightInfoWDS;            lightInfoWDS.dstSet = set;            lightInfoWDS.dstBinding = LightInfoBinding;            lightInfoWDS.dstArrayElement = 0;            lightInfoWDS.descriptorType = vk::DescriptorType::eUniformBuffer;            lightInfoWDS.descriptorCount = 1;            lightInfoWDS.pBufferInfo = &lightInfoBufferInfo;            vk::DescriptorBufferInfo lightBufferBufferInfo;            lightBufferBufferInfo.buffer = LightBuffer->VkBuffer;            lightBufferBufferInfo.offset = 0;            lightBufferBufferInfo.range = vk::WholeSize;            vk::WriteDescriptorSet lightBufferWDS;            lightBufferWDS.dstSet = set;            lightBufferWDS.dstBinding = LightBufferBinding;            lightBufferWDS.dstArrayElement = 0;            lightBufferWDS.descriptorType = vk::DescriptorType::eStorageBuffer;            lightBufferWDS.descriptorCount = 1;            lightBufferWDS.pBufferInfo = &lightBufferBufferInfo;            Graphics::GetDevice().updateDescriptorSets({lightInfoWDS, lightBufferWDS}, nullptr);        }        // Shadows        std::vector<vk::DescriptorImageInfo> shadowImageInfos(MaxShadowCount, vk::DescriptorImageInfo{});        std::vector<vk::WriteDescriptorSet> shadowImageWDSes(MaxShadowCount, vk::WriteDescriptorSet{});        for (size_t i = 0; i < MaxShadowCount; i++)        {            const auto shadowImage = (i < ShadowImages.size()) ? ShadowImages[i] : Texture::GetWhiteTexture()->GetImage();            assert(ShadowSampler != nullptr && ShadowSampler->GetSampler() != nullptr);            assert(shadowImage->GetMainImageView() != nullptr);            auto &info = shadowImageInfos[i];            info.sampler = ShadowSampler->GetSampler();            info.imageLayout = vk::ImageLayout::eShaderReadOnlyOptimal;            info.imageView = shadowImage->GetMainImageView();            auto &wds = shadowImageWDSes[i];            wds.dstSet = set;            wds.dstBinding = ShadowBinding;            wds.dstArrayElement = i;            wds.descriptorType = vk::DescriptorType::eCombinedImageSampler;            wds.descriptorCount = 1;            wds.pImageInfo = &info;        }        Graphics::GetDevice().updateDescriptorSets(shadowImageWDSes, nullptr);    }    std::vector<vk::DescriptorSetLayoutBinding> Lighting::GetDescriptorSetLayoutBindings(uint32_t shadowCount)    {        // Light storage buffer and uniform        auto layoutBindings = std::vector<vk::DescriptorSetLayoutBinding>{            vk::DescriptorSetLayoutBinding(0, vk::DescriptorType::eUniformBuffer, 1, vk::ShaderStageFlagBits::eFragment, nullptr),            vk::DescriptorSetLayoutBinding(1, vk::DescriptorType::eStorageBuffer, 1, vk::ShaderStageFlagBits::eFragment, nullptr),        };        // Shadow bindless textures        if (shadowCount > 0)        {            layoutBindings.emplace_back(2, vk::DescriptorType::eCombinedImageSampler, shadowCount, vk::ShaderStageFlagBits::eFragment, nullptr);        }        return layoutBindings;    }    std::vector<vk::DescriptorBindingFlags> Lighting::GetDescriptorBindingFlags(uint32_t shadowCount)    {        // Light storage buffer and uniform        auto flags = std::vector<vk::DescriptorBindingFlags>{            vk::DescriptorBindingFlagBits::eUpdateAfterBind,            vk::DescriptorBindingFlagBits::eUpdateAfterBind,        };        // Shadow bindless textures        if (shadowCount > 0)        {            flags.push_back(vk::DescriptorBindingFlagBits::ePartiallyBound | vk::DescriptorBindingFlagBits::eUpdateAfterBind);        }        return flags;    }    Lighting::Pointer Lighting::CreateLighting(uint32_t lightCount, uint32_t shadowCount)    {        return std::make_shared<Lighting>(lightCount, shadowCount);    }} // Spinner#include <utility>